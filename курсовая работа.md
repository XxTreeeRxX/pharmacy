<p align="center">Министерство образования, науки и молодежной политики Республики Коми</p>

<p align="center">ГПОУ "Сыктывкарский политехнический техникум"</p>






<p align="center">Курсовая работа</p>



<p align="center">Тема: База данных Аптеки</p>















<p align="right"> выполнил </p>

<p align="right">студент 4 курса </p>

<p align="right">414 группы </p>

<p align="right">Вокуев Евений Юрьевич</p>



<p align="right">проверил</p>

<p align="right">Пунгин И.В.</p>

<p align="right">дата проверки: ______________</p>










<p align="center">Сыктывкар, 2025</p>






# Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы:База данных Аптеки

Срок представления работы к защите: <ins> ... апреля 2025 года. </ins>

Перечень подлежащих разработке вопросов:

1. Анализ предметной области. Постановка задачи.

    1.1. Описание предметной области и функции решаемых задач.

    1.2. Перечень входных данных.

    1.3. Перечень выходных данных

    1.4. Ограничения предметной области (если таковые имеются).

    1.5. Взаимодействие с другими программами.

2. Инфологическая (концептуальная) модель базы данных.

    2.1. Выделение информационных объектов.

    2.2. Определение атрибутов объектов.

    2.3. Определение отношений и мощности отношений между объектами.

    2.4. Построение концептуальной модели.

3. Логическая структура БД.

4. Физическая структура базы данных.

5. Реализация проекта в среде конкретной СУБД.

    5.1. Создание таблиц и индексов.

    5.2. Создание представлений и функций.

    5.3. Разработка интерфейса.

    5.4. Назначение прав доступа.

    5.5. Разработка стратегии резервного копирования базы данных.


Руководитель работы _________________________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _________________________________ <ins> Е. Ю. Вокуев </ins>

## <a id="content">Содержание</a>

1. [Введение](#introduction)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)

 
# <a id="introduction">**Введение**</a> 

В современных условиях фармацевтической отрасли эффективное управление данными становится ключевым фактором в работе аптечного бизнеса. Автоматизация процессов учета лекарственных средств, управления запасами, взаимодействия с клиентами и поставщиками требует внедрения специализированной  базы данных , что обуславливает актуальность разработки информационной системы для аптечного бизнеса. Такая система должна обеспечивать централизованное хранение данных о лекарствах, заказах, клиентах, сотрудниках и поставщиках, а также предоставлять инструменты для анализа и оптимизации операций.  

Внедрение автоматизированной базы данных позволит:  
- Сократить время на ручной учет и анализ данных.  
- Минимизировать ошибки при управлении запасами и формировании заказов.  
- Оперативно отслеживать сроки годности лекарств и предотвращать их списание.  
- Персонализировать взаимодействие с клиентами на основе их предпочтений и истории покупок.  

Ключевая задача проекта — создание системы, которая объединит данные о лекарственных средствах, заказах, клиентах и поставщиках, обеспечив:  
- Автоматическое обновление остатков лекарств на складе при совершении продаж или закупок.  
- Формирование отчетов по динамике продаж, потребности в закупках и эффективности работы сотрудников.
- Защиту конфиденциальных данных (рецепты, контакты клиентов) через ролевую модель доступа.  

Разработанная подсистема станет инструментом для:  
- Прогнозирования спроса на лекарственные средства с использованием исторических данных.  
- Оптимизации закупок за счет анализа остатков и сроков годности.  
- Ускорения обслуживания клиентов благодаря автоматизации процессов оформления заказов. 

Таким образом, курсовая работа направлена на создание базы данных, которая не только автоматизирует текущие задачи аптечного бизнеса, но и станет основой для внедрения AI-решений в будущем, таких как прогнозирование спроса или генерация персональных рекомендаций для клиентов.  

## Цель работы

**Цель курсовой работы:** Создание и реализация базы данных для увеличения удобства работы и хранения сведений о состоянии Аптеки. Контроль продаж, поступления продукции, состояния склада.

1. **Создание структуры базы данных**:  
   Разработать схему БД, отражающую ключевые сущности аптечного бизнеса: лекарственные средства, заказы, клиенты, сотрудники, поставщики и рецепты. Обеспечить целостность данных за счет нормализации таблиц, установки связей (например, между лекарствами и поставщиками) и ограничений (проверка цен, количества, сроков годности).  

2. **Реализация функционала для управления аптечными процессами**:  
   Создать механизмы для:  
   - Регистрации новых лекарственных средств с привязкой к поставщикам.  
   - Учета продаж и закупок с автоматическим обновлением остатков.  
   - Контроля сроков годности лекарств и предотвращения их списания.  

3. **Разработка аналитических инструментов**:  
   Реализовать представления и запросы для:  
   - Анализа эффективности продаж по ключевым метрикам (выручка, количество проданных единиц).  
   - Формирования отчетов по динамике спроса на лекарственные средства в разрезе категорий и производителей.  
   - Прогнозирования потребности в закупках на основе исторических данных.  

4. **Обеспечение безопасности и ролевого доступа**:  
   Внедрить модель разграничения прав:  
   - **Фармацевты** — управление продажами и рецептами.  
   - **Менеджеры** — контроль закупок и взаимодействие с поставщиками.  
   - **Администраторы** — полный контроль над данными, включая настройку прав.  
   Защитить конфиденциальные данные (рецепты, контакты клиентов) через шифрование и аудит изменений.  
   - **Гости** - просмотр ассортимента лекарств магазина
5. **Документирование системы**:  
   Подготовить:  
   - Техническую документацию (ER-диаграммы, описание таблиц, SQL-скрипты).  
   - Руководство пользователя 

**Итоговая цель** — создание системы, которая не только автоматизирует текущие задачи аптечного бизнеса, но и станет основой для:  
- Оптимизации закупок за счет анализа данных в реальном времени.
- Внедрения решений для прогнозирования спроса и автоматизации процессов.  

Таким образом, разработанная база данных позволит аптеке повысить эффективность операционных процессов и сократить издержки.

# <a id=analysis>1. Анализ предметной области. Постановка задачи</a>

## 1.1. Описание предметной области и функции решаемых задач

**Предметная область:**  
Проект представляет собой информационную систему для управления аптечной базой данных. Система предназначена для автоматизации процессов учета лекарственных средств, управления закупками и продажами, а также мониторинга запасов и отчетности.

Основные функции системы:
- Управление данными о клиентах, сотрудниках, поставщиках
- Учет лекарственных средств (информация о производителях, ценах, сроках годности, наличии на складе)
- Ведение записей о рецептах, выданных врачами
- Управление закупками и продажами
- Контроль запасов и управление инвентаризацией
- Генерация отчетов
- Аутентификация пользователей и управление доступом на основе ролей

## 1.2. Перечень входных данных

Входные данные включают следующие категории:

1. **Данные о пользователях:**
   - Логин, пароль, роль (администратор, фармацевт, менеджер, гость)

2. **Данные о клиентах:**
   - Имя, фамилия, телефон, email, адрес

3. **Данные о сотрудниках:**
   - Имя, фамилия, должность, телефон, email, дата найма, зарплата

4. **Данные о поставщиках:**
   - Название компании, контактное лицо, телефон, email, адрес

5. **Данные о лекарствах:**
   - Название, описание, производитель, цена, количество на складе, срок годности, информация о поставщике

6. **Данные о рецептах:**
   - Информация о клиенте, лекарстве, враче, дата выдачи, срок действия

7. **Данные о закупках:**
   - Дата закупки, поставщик, общая сумма

8. **Данные о продажах:**
   - Дата продажи, клиент, сотрудник, общая сумма

9. **Детализация закупок и продаж:**
   - Лекарство, количество, цена за единицу

## 1.3. Перечень выходных данных

Выходные данные формируются в виде:
1. **Таблицы данных:**
   - Таблицы клиентов, сотрудников, поставщиков, лекарств, рецептов, закупок, продаж и их детализации

2. **Отчеты:**
   - Простые остатки товаров на складе
   - Будущие поставки (закупки)
   - Продажи за последние 30 дней
   - Статистика расхода лекарств

3. **Экспорт данных:**
   - Возможность экспорта данных в CSV-файлы для дальнейшего анализа

4. **Уведомления и статусы:**
   - Сообщения об успешных операциях
   - Предупреждения о недостаточном количестве товаров на складе

## 1.4. Ограничения предметной области

1. **Ограничения на данные:**
   - Цены и количества должны быть положительными числами
   - Срок годности лекарств не может быть меньше текущей даты
   - Пользователи с ролью "гость" имеют ограниченный доступ только к просмотру данных

2. **Ограничения на бизнес-логику:**
   - Продажа невозможна, если товара недостаточно на складе
   - Удаление записей о закупках или продажах требует подтверждения из-за связанных данных

3. **Ограничения безопасности:**
   - Только администраторы могут управлять пользователями системы
   - Пароли хранятся в зашифрованном виде

4. **Ограничения интерфейса:**
   - Интерфейс доступен только через графическое приложение

## 1.5. Взаимодействие с другими программами

1. **База данных:**
   - Система использует PostgreSQL для хранения данных. Взаимодействие осуществляется через библиотеку `psycopg2`

2. **Экспорт данных:**
   - Данные могут экспортироваться в CSV-файлы для использования в сторонних программах (например, Excel)

3. **Логирование:**
   - Логи записываются в файл `pharmacy_app.log` для последующего анализа

4. **Резервное копирование:**
   - Реализуется через средства PostgreSQL (например, `pg_dump`)

# <a id=infological_model>2. Инфологическая (концептуальная) модель базы данных</a>

## 2.1. Выделение информационных объектов

Основные объекты предметной области:
- Пользователи (`app_users`).
- Клиенты (`customers`).
- Сотрудники (`employees`).
- Поставщики (`suppliers`).
- Лекарства (`medicines`).
- Рецепты (`prescriptions`).
- Закупки (`purchases`) и их детализация (`purchase_items`).
- Продажи (`sales`) и их детализация (`sale_items`).

---

## 2.2. Определение атрибутов объектов

| Объект          | Атрибуты                                                                 |
|------------------|--------------------------------------------------------------------------|
| Пользователи     | user_id, username, password_hash, role                                   |
| Клиенты          | customer_id, first_name, last_name, phone, email, address                |
| Сотрудники       | employee_id, first_name, last_name, position, phone, email, hire_date, salary |
| Поставщики       | supplier_id, name, contact_person, phone, email, address                 |
| Лекарства        | medicine_id, name, description, manufacturer, price, quantity_in_stock, expiration_date, supplier_id |
| Рецепты          | prescription_id, customer_id, medicine_id, doctor_name, issue_date, expiration_date |
| Закупки          | purchase_id, purchase_date, supplier_id, total_amount                    |
| Детали закупок   | purchase_item_id, purchase_id, medicine_id, quantity, price              |
| Продажи          | sale_id, sale_date, customer_id, employee_id, total_amount               |
| Детали продаж    | sale_item_id, sale_id, medicine_id, quantity, price                      |

---

## 2.3. Определение отношений и мощности отношений между объектами

| Отношение                  | Мощность            | Описание                                                                 |
|----------------------------|---------------------|--------------------------------------------------------------------------|
| Пользователи → Роли         | 1:1                 | Каждый пользователь имеет одну роль.                                     |
| Клиенты → Рецепты           | 1:N                 | Один клиент может иметь несколько рецептов.                               |
| Сотрудники → Продажи        | 1:N                 | Один сотрудник может участвовать в нескольких продажах.                   |
| Поставщики → Закупки        | 1:N                 | Один поставщик может участвовать в нескольких закупках.                   |
| Лекарства → Рецепты         | 1:N                 | Одно лекарство может быть указано в нескольких рецептах.                   |
| Лекарства → Закупки         | 1:N                 | Одно лекарство может быть частью нескольких закупок.                       |
| Лекарства → Продажи         | 1:N                 | Одно лекарство может быть частью нескольких продаж.                        |
| Закупки → Детали закупок    | 1:N                 | Одна закупка может содержать несколько позиций.                           |
| Продажи → Детали продаж     | 1:N                 | Одна продажа может содержать несколько позиций.                           |

---

## 2.4. Построение концептуальной модели

![pharmacy - public](https://github.com/XxTreeeRxX/pharmacy/blob/c3588d903e79fe9de930084486c11a50a2c4e2dd/ER-diagram.png)
  
Концептуальная модель представлена в виде ER-диаграммы, где:
- Сущности представлены прямоугольниками.
- Атрибуты перечислены внутри сущностей.
- Отношения показаны стрелками с указанием мощности.

---

# <a id=logical_structure>3. Логическая структура БД</a>

## 3.1. Разработка основных элементов логической структуры
Логическая структура базы данных описывает, как данные организованы в таблицах, их атрибуты, связи между таблицами и ограничения целостности. Она строится на основе инфологической модели и адаптируется к возможностям конкретной СУБД (в данном случае PostgreSQL). Основные элементы логической структуры:

### **Таблица `app_users` (Пользователи системы)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `user_id`        | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `username`       | VARCHAR(255)    | Логин пользователя        | UNIQUE, NOT NULL                |  
| `password_hash`  | VARCHAR(255)    | Хеш пароля               | NOT NULL                        |  
| `role`           | VARCHAR(50)     | Роль пользователя         | NOT NULL                        |  

---

### **Таблица `customers` (Клиенты)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `customer_id`    | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `first_name`     | VARCHAR(255)    | Имя клиента               | NOT NULL                        |  
| `last_name`      | VARCHAR(255)    | Фамилия клиента           | NOT NULL                        |  
| `phone`          | VARCHAR(20)     | Телефон                   |                                 |  
| `email`          | VARCHAR(255)    | Email                     |                                 |  
| `address`        | TEXT            | Адрес клиента             |                                 |  

---

### **Таблица `employees` (Сотрудники)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `employee_id`    | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `first_name`     | VARCHAR(255)    | Имя сотрудника            | NOT NULL                        |  
| `last_name`      | VARCHAR(255)    | Фамилия сотрудника        | NOT NULL                        |  
| `position`       | VARCHAR(255)    | Должность                 | NOT NULL                        |  
| `phone`          | VARCHAR(20)     | Телефон                   |                                 |  
| `email`          | VARCHAR(255)    | Email                     |                                 |  
| `hire_date`      | DATE            | Дата найма                | NOT NULL                        |  
| `salary`         | NUMERIC(10,2)   | Зарплата                  | NOT NULL                        |  

---

### **Таблица `suppliers` (Поставщики)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `supplier_id`    | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `name`           | VARCHAR(255)    | Название поставщика       | NOT NULL                        |  
| `contact_person` | VARCHAR(255)    | Контактное лицо           |                                 |  
| `phone`          | VARCHAR(20)     | Телефон                   |                                 |  
| `email`          | VARCHAR(255)    | Email                     |                                 |  
| `address`        | TEXT            | Адрес поставщика          |                                 |  

---

### **Таблица `medicines` (Лекарства)**  
| Атрибут              | Тип данных       | Описание                  | Ограничения                     |  
|----------------------|------------------|---------------------------|---------------------------------|  
| `medicine_id`        | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `name`               | VARCHAR(255)    | Название лекарства        | NOT NULL                        |  
| `description`        | TEXT            | Описание                  |                                 |  
| `manufacturer`       | VARCHAR(255)    | Производитель             |                                 |  
| `price`              | NUMERIC(10,2)   | Цена                      | CHECK (`price` > 0)            |  
| `quantity_in_stock`  | INTEGER         | Количество на складе      | CHECK (`quantity_in_stock` >= 0)|  
| `expiration_date`    | DATE            | Срок годности             | NOT NULL                        |  
| `supplier_id`        | INTEGER         | ID поставщика             | FOREIGN KEY REFERENCES `suppliers` |  

---

### **Таблица `prescriptions` (Рецепты)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `prescription_id`| SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `customer_id`    | INTEGER         | ID клиента                | FOREIGN KEY REFERENCES `customers` |  
| `medicine_id`    | INTEGER         | ID лекарства              | FOREIGN KEY REFERENCES `medicines` |  
| `doctor_name`    | VARCHAR(255)    | Имя врача                 | NOT NULL                        |  
| `issue_date`     | DATE            | Дата выдачи рецепта       | NOT NULL                        |  
| `expiration_date`| DATE            | Срок действия рецепта     | CHECK (`expiration_date` > `issue_date`) |  

---

### **Таблица `purchases` (Закупки)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `purchase_id`    | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `purchase_date`  | TIMESTAMP       | Дата закупки              | DEFAULT CURRENT_TIMESTAMP       |  
| `supplier_id`    | INTEGER         | ID поставщика             | FOREIGN KEY REFERENCES `suppliers` |  
| `total_amount`   | NUMERIC(10,2)   | Общая сумма               | NOT NULL                        |  

---

### **Таблица `sales` (Продажи)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `sale_id`        | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `sale_date`      | TIMESTAMP       | Дата продажи              | DEFAULT CURRENT_TIMESTAMP       |  
| `customer_id`    | INTEGER         | ID клиента                | FOREIGN KEY REFERENCES `customers` |  
| `employee_id`    | INTEGER         | ID сотрудника             | FOREIGN KEY REFERENCES `employees` |  
| `total_amount`   | NUMERIC(10,2)   | Общая сумма               | NOT NULL                        |  

---

### **Таблица `purchase_items` (Позиции закупок)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `purchase_item_id`| SERIAL         | Уникальный идентификатор  | PRIMARY KEY                     |  
| `purchase_id`    | INTEGER         | ID закупки                | FOREIGN KEY REFERENCES `purchases` |  
| `medicine_id`    | INTEGER         | ID лекарства              | FOREIGN KEY REFERENCES `medicines` |  
| `quantity`       | INTEGER         | Количество                | NOT NULL                        |  
| `price`          | NUMERIC(10,2)   | Цена                      | NOT NULL                        |  

---

### **Таблица `sale_items` (Позиции продаж)**  
| Атрибут         | Тип данных       | Описание                  | Ограничения                     |  
|------------------|------------------|---------------------------|---------------------------------|  
| `sale_item_id`   | SERIAL          | Уникальный идентификатор  | PRIMARY KEY                     |  
| `sale_id`        | INTEGER         | ID продажи                | FOREIGN KEY REFERENCES `sales`  |  
| `medicine_id`    | INTEGER         | ID лекарства              | FOREIGN KEY REFERENCES `medicines` |  
| `quantity`       | INTEGER         | Количество                | NOT NULL                        |  
| `price`          | NUMERIC(10,2)   | Цена                      | NOT NULL                        |  

---
## **3.2. Связи между таблицами**

### **1. Таблица `app_users` (Пользователи системы)**  
- **Связь с таблицей `employees`:**  
  - Один пользователь может быть связан с одним сотрудником через внешний ключ `user_id`.  
  - Связь: `employees.user_id` → `app_users.user_id` (**1:1**).  

- **Связь с таблицей `customers`:**  
  - Один пользователь может быть связан с одним клиентом через внешний ключ `user_id`.  
  - Связь: `customers.user_id` → `app_users.user_id` (**1:1**).  

---

### **2. Таблица `customers` (Клиенты)**  
- **Связь с таблицей `prescriptions`:**  
  - Один клиент может иметь много рецептов.  
  - Связь: `customers.customer_id` → `prescriptions.customer_id` (**1:N**).  

- **Связь с таблицей `sales`:**  
  - Один клиент может совершать много продаж.  
  - Связь: `customers.customer_id` → `sales.customer_id` (**1:N**).  

---

### **3. Таблица `employees` (Сотрудники)**  
- **Связь с таблицей `sales`:**  
  - Один сотрудник может участвовать в оформлении многих продаж.  
  - Связь: `employees.employee_id` → `sales.employee_id` (**1:N**).  

---

### **4. Таблица `suppliers` (Поставщики)**  
- **Связь с таблицей `medicines`:**  
  - Один поставщик может поставлять много лекарств.  
  - Связь: `suppliers.supplier_id` → `medicines.supplier_id` (**1:N**).  

- **Связь с таблицей `purchases`:**  
  - Один поставщик может участвовать в закупке многих товаров.  
  - Связь: `suppliers.supplier_id` → `purchases.supplier_id` (**1:N**).  

---

### **5. Таблица `medicines` (Лекарства)**  
- **Связь с таблицей `purchase_items`:**  
  - Одно лекарство может быть частью многих позиций закупок.  
  - Связь: `medicines.medicine_id` → `purchase_items.medicine_id` (**1:N**).  

- **Связь с таблицей `sale_items`:**  
  - Одно лекарство может быть частью многих позиций продаж.  
  - Связь: `medicines.medicine_id` → `sale_items.medicine_id` (**1:N**).  

- **Связь с таблицей `prescriptions`:**  
  - Одно лекарство может быть указано в нескольких рецептах.  
  - Связь: `medicines.medicine_id` → `prescriptions.medicine_id` (**1:N**).  

---

### **6. Таблица `prescriptions` (Рецепты)**  
- **Связь с таблицей `customers`:**  
  - Один рецепт принадлежит одному клиенту.  
  - Связь: `prescriptions.customer_id` → `customers.customer_id` (**N:1**).  

- **Связь с таблицей `medicines`:**  
  - Один рецепт содержит одно лекарство.  
  - Связь: `prescriptions.medicine_id` → `medicines.medicine_id` (**N:1**).  

---

### **7. Таблица `purchases` (Закупки)**  
- **Связь с таблицей `suppliers`:**  
  - Одна закупка связана с одним поставщиком.  
  - Связь: `purchases.supplier_id` → `suppliers.supplier_id` (**N:1**).  

- **Связь с таблицей `purchase_items`:**  
  - Одна закупка может содержать много позиций закупок.  
  - Связь: `purchases.purchase_id` → `purchase_items.purchase_id` (**1:N**).  

---

### **8. Таблица `sales` (Продажи)**  
- **Связь с таблицей `customers`:**  
  - Одна продажа связана с одним клиентом.  
  - Связь: `sales.customer_id` → `customers.customer_id` (**N:1**).  

- **Связь с таблицей `employees`:**  
  - Одна продажа связана с одним сотрудником.  
  - Связь: `sales.employee_id` → `employees.employee_id` (**N:1**).  

- **Связь с таблицей `sale_items`:**  
  - Одна продажа может содержать много позиций продаж.  
  - Связь: `sales.sale_id` → `sale_items.sale_id` (**1:N**).  

---

### **9. Таблица `purchase_items` (Позиции закупок)**  
- **Связь с таблицей `purchases`:**  
  - Одна позиция закупки связана с одной закупкой.  
  - Связь: `purchase_items.purchase_id` → `purchases.purchase_id` (**N:1**).  

- **Связь с таблицей `medicines`:**  
  - Одна позиция закупки связана с одним лекарством.  
  - Связь: `purchase_items.medicine_id` → `medicines.medicine_id` (**N:1**).  

---

### **10. Таблица `sale_items` (Позиции продаж)**  
- **Связь с таблицей `sales`:**  
  - Одна позиция продажи связана с одной продажей.  
  - Связь: `sale_items.sale_id` → `sales.sale_id` (**N:1**).  

- **Связь с таблицей `medicines`:**  
  - Одна позиция продажи связана с одним лекарством.  
  - Связь: `sale_items.medicine_id` → `medicines.medicine_id` (**N:1**).  

---

# <a id=physical_structure>4. Физическая структура базы данных</a>

## **4.1. Хранение данных**
Данные хранятся в файлах таблиц PostgreSQL. Каждая таблица имеет свое пространство хранения, которое организовано в виде файлов на диске. Эти файлы управляются PostgreSQL и автоматически разбиваются на сегменты при увеличении объема данных.

### Пример:
При создании таблицы `medicines` PostgreSQL создает соответствующий файл для хранения данных этой таблицы. Файл хранится в каталоге данных кластера PostgreSQL (например, `/var/lib/postgresql/data/base/`).

```sql
-- Создание таблицы medicines
CREATE TABLE medicines (
    medicine_id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    manufacturer VARCHAR(255),
    price NUMERIC(10, 2) CHECK (price > 0),
    quantity_in_stock INTEGER CHECK (quantity_in_stock >= 0),
    expiration_date DATE NOT NULL,
    supplier_id INTEGER REFERENCES suppliers(supplier_id)
);
```

- **Файлы:** PostgreSQL создает файлы для хранения данных таблицы, индексов и метаданных.
- **Разделение:** Если размер таблицы превышает 1 ГБ, PostgreSQL автоматически разбивает её на сегменты (файлы с суффиксами `_fsm`, `_vm`).

---

## **4.2. Последовательности (Sequences)**
Последовательности используются для генерации уникальных значений первичных ключей. Они гарантируют, что каждая запись имеет уникальный идентификатор.

### Пример:
Создание последовательности для таблицы `medicines`:

```sql
-- Создание последовательности для medicine_id
CREATE SEQUENCE medicines_medicine_id_seq
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 2147483647
    START 1
    CACHE 1
    NO CYCLE;

-- Использование последовательности в таблице
ALTER TABLE medicines
    ALTER COLUMN medicine_id SET DEFAULT nextval('medicines_medicine_id_seq');
```

- **Файлы:** Последовательности также хранятся в отдельных файлах, связанных с таблицами.
- **Особенности:** Последовательности не зависят от транзакций, поэтому их значения сохраняются даже после отката.

---

## **4.3. Индексы**
Индексы ускоряют поиск данных, используя структуры данных, такие как B-деревья. Они хранятся отдельно от данных таблицы.

### Пример:
Создание индекса для столбца `supplier_id` в таблице `medicines`:

```sql
-- Создание индекса
CREATE INDEX idx_medicines_supplier ON medicines USING btree (supplier_id);

-- Объяснение запроса с использованием индекса
EXPLAIN ANALYZE
SELECT * FROM medicines WHERE supplier_id = 1;
```

- **Типы индексов:** PostgreSQL поддерживает различные типы индексов, включая B-деревья, GiST, GIN и BRIN.
- **Преимущества:** Индексы ускоряют выполнение запросов, но замедляют операции вставки и обновления.

---

## **4.4. Триггеры и функции**

Функции и хранимые процедуры позволяют выполнять сложные операции непосредственно в базе данных. Они могут быть написаны на PL/pgSQL или других языках. В данном случае мы используем функцию `update_sequence_after_delete`, которая автоматически обновляет последовательности после удаления записей.

### Пример:
Функция `update_sequence_after_delete` используется для корректировки последовательностей (`sequences`) после удаления записей. Это важно для поддержания целостности данных и предотвращения конфликтов при создании новых записей.

```sql
-- Определение функции update_sequence_after_delete
CREATE OR REPLACE FUNCTION public.update_sequence_after_delete()
RETURNS TRIGGER AS $function$
BEGIN
    -- Обновление последовательности для таблицы, из которой была удалена запись
    EXECUTE format(
        'SELECT setval(''%s_%s_seq'', (SELECT COALESCE(MAX(%I), 0) + 1 FROM %I))',
        TG_TABLE_NAME, -- Имя таблицы
        TG_ARGV[0],     -- Первичный ключ (передается как аргумент триггера)
        TG_ARGV[0],     -- Первичный ключ (для MAX)
        TG_TABLE_NAME   -- Имя таблицы
    );
    RETURN NULL;
END;
$function$
LANGUAGE plpgsql;
```

### Как работает функция:

1. **Параметры триггера:**
   - `TG_TABLE_NAME`: Имя таблицы, из которой была удалена запись.
   - `TG_ARGV[0]`: Имя первичного ключа таблицы (передается как аргумент триггера).

2. **Логика работы:**
   - Функция выполняет запрос `setval` для соответствующей последовательности.
   - Она находит максимальное значение первичного ключа в таблице и устанавливает следующее значение последовательности на `MAX + 1`.
   - Если таблица пуста (`MAX` возвращает `NULL`), используется значение `0 + 1`.

3. **Пример использования:**
   Эта функция вызывается автоматически через триггеры, которые настроены для каждой таблицы. Например:

```sql
-- Создание триггера для таблицы medicines
CREATE TRIGGER trg_medicines_after_delete
AFTER DELETE ON public.medicines
FOR EACH ROW
EXECUTE FUNCTION update_sequence_after_delete('medicine_id');
```

### Триггеры для всех таблиц:
Вот примеры триггеров, которые используют эту функцию для различных таблиц:

```sql
-- Триггер для таблицы customers
CREATE TRIGGER trg_customers_after_delete
AFTER DELETE ON public.customers
FOR EACH ROW
EXECUTE FUNCTION update_sequence_after_delete('customer_id');

-- Триггер для таблицы employees
CREATE TRIGGER trg_employees_after_delete
AFTER DELETE ON public.employees
FOR EACH ROW
EXECUTE FUNCTION update_sequence_after_delete('employee_id');

-- Триггер для таблицы suppliers
CREATE TRIGGER trg_suppliers_after_delete
AFTER DELETE ON public.suppliers
FOR EACH ROW
EXECUTE FUNCTION update_sequence_after_delete('supplier_id');

-- Триггер для таблицы sales
CREATE TRIGGER trg_sales_after_delete
AFTER DELETE ON public.sales
FOR EACH ROW
EXECUTE FUNCTION update_sequence_after_delete('sale_id');
```

### Преимущества:
- **Автоматизация:** Функция автоматически обновляет последовательности, что исключает необходимость ручного вмешательства.
- **Целостность данных:** Предотвращает конфликты при создании новых записей (например, дублирование значений первичного ключа).
- **Масштабируемость:** Подходит для любых таблиц с автоинкрементными первичными ключами.

---

### **Результат выполнения**
Если вы удалите запись из таблицы, например, из `medicines`, триггер автоматически вызовет функцию `update_sequence_after_delete`. Это гарантирует, что последовательность `medicines_medicine_id_seq` будет обновлена до значения `MAX(medicine_id) + 1`.

### Пример:
```sql
-- Удаление записи из таблицы medicines
DELETE FROM medicines WHERE medicine_id = 10;

-- Проверка значения последовательности
SELECT last_value FROM medicines_medicine_id_seq;
```

После выполнения этого запроса последовательность будет обновлена до значения, соответствующего текущему максимальному `medicine_id` в таблице.

---

Таким образом, использование функции `update_sequence_after_delete` и связанных триггеров обеспечивает надежное управление последовательностями в базе данных, что особенно важно для систем с частыми операциями удаления записей.



## **4.5. Резервное копирование**
Регулярное резервное копирование защищает данные от потери. PostgreSQL предоставляет инструменты для создания полных и инкрементальных резервных копий.

### Пример:
Создание резервной копии с помощью `pg_dump`:

```bash
# Полная резервная копия
pg_dump -U postgres -Fc pharmacy > pharmacy_backup.dump

# Восстановление из резервной копии
pg_restore -U postgres -d pharmacy pharmacy_backup.dump
```

- **Автоматизация:** Можно настроить cron-задачи для регулярного резервного копирования.
- **Инкрементальные копии:** Используйте WAL-архивирование для создания инкрементальных резервных копий.

---


# <a id=project_realization>5. Реализация проекта в среде конкретной СУБД</a>

## 5.1. Создание таблиц и индексов

Таблицы создаются с использованием SQL-скриптов. Вот полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

---
```sql
-- Таблица пользователей приложения
CREATE TABLE public.app_users (
    user_id serial4 NOT NULL,
    username varchar(255) NOT NULL,
    password_hash varchar(255) NOT NULL,
    "role" varchar(50) NOT NULL,
    CONSTRAINT app_users_pkey PRIMARY KEY (user_id),
    CONSTRAINT app_users_username_key UNIQUE (username)
);
```
```sql
-- Таблица клиентов
CREATE TABLE public.customers (
    customer_id serial4 NOT NULL,
    first_name varchar(255) NOT NULL,
    last_name varchar(255) NOT NULL,
    phone varchar(20) NULL,
    email varchar(255) NULL,
    address text NULL,
    CONSTRAINT customers_pkey PRIMARY KEY (customer_id)
);
```
```sql
-- Таблица сотрудников
CREATE TABLE public.employees (
    employee_id serial4 NOT NULL,
    first_name varchar(255) NOT NULL,
    last_name varchar(255) NOT NULL,
    "position" varchar(255) NOT NULL,
    phone varchar(20) NULL,
    email varchar(255) NULL,
    hire_date date NOT NULL,
    salary numeric(10, 2) NOT NULL,
    CONSTRAINT employees_pkey PRIMARY KEY (employee_id)
);
```
```sql
-- Таблица поставщиков
CREATE TABLE public.suppliers (
    supplier_id serial4 NOT NULL,
    "name" varchar(255) NOT NULL,
    contact_person varchar(255) NULL,
    phone varchar(20) NULL,
    email varchar(255) NULL,
    address text NULL,
    CONSTRAINT suppliers_pkey PRIMARY KEY (supplier_id)
);
```
```sql
-- Таблица лекарств
CREATE TABLE public.medicines (
    medicine_id serial4 NOT NULL,
    "name" varchar(255) NOT NULL,
    description text NULL,
    manufacturer varchar(255) NULL,
    price numeric(10, 2) NOT NULL,
    quantity_in_stock int4 NOT NULL,
    expiration_date date NOT NULL,
    supplier_id int4 NULL,
    CONSTRAINT chk_price CHECK ((price > (0)::numeric)),
    CONSTRAINT chk_quantity CHECK ((quantity_in_stock >= 0)),
    CONSTRAINT medicines_pkey PRIMARY KEY (medicine_id),
    CONSTRAINT medicines_supplier_id_fkey FOREIGN KEY (supplier_id) REFERENCES public.suppliers(supplier_id)
);
```
```sql
-- Таблица рецептов
CREATE TABLE public.prescriptions (
    prescription_id serial4 NOT NULL,
    customer_id int4 NULL,
    medicine_id int4 NULL,
    doctor_name varchar(255) NOT NULL,
    issue_date date NOT NULL,
    expiration_date date NOT NULL,
    CONSTRAINT chk_dates CHECK ((expiration_date > issue_date)),
    CONSTRAINT prescriptions_pkey PRIMARY KEY (prescription_id),
    CONSTRAINT prescriptions_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(customer_id),
    CONSTRAINT prescriptions_medicine_id_fkey FOREIGN KEY (medicine_id) REFERENCES public.medicines(medicine_id)
);
```
```sql
-- Таблица закупок
CREATE TABLE public.purchases (
    purchase_id serial4 NOT NULL,
    purchase_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
    supplier_id int4 NULL,
    total_amount numeric(10, 2) NOT NULL,
    CONSTRAINT purchases_pkey PRIMARY KEY (purchase_id),
    CONSTRAINT purchases_supplier_id_fkey FOREIGN KEY (supplier_id) REFERENCES public.suppliers(supplier_id)
);
```
```sql
-- Таблица продаж
CREATE TABLE public.sales (
    sale_id serial4 NOT NULL,
    sale_date timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
    customer_id int4 NULL,
    employee_id int4 NULL,
    total_amount numeric(10, 2) NOT NULL,
    CONSTRAINT sales_pkey PRIMARY KEY (sale_id),
    CONSTRAINT sales_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(customer_id),
    CONSTRAINT sales_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES public.employees(employee_id)
);
```
```sql
-- Позиции закупок
CREATE TABLE public.purchase_items (
    purchase_item_id serial4 NOT NULL,
    purchase_id int4 NULL,
    medicine_id int4 NULL,
    quantity int4 NOT NULL,
    price numeric(10, 2) NOT NULL,
    CONSTRAINT purchase_items_pkey PRIMARY KEY (purchase_item_id),
    CONSTRAINT purchase_items_medicine_id_fkey FOREIGN KEY (medicine_id) REFERENCES public.medicines(medicine_id),
    CONSTRAINT purchase_items_purchase_id_fkey FOREIGN KEY (purchase_id) REFERENCES public.purchases(purchase_id)
);
```
```sql
-- Позиции продаж
CREATE TABLE public.sale_items (
    sale_item_id serial4 NOT NULL,
    sale_id int4 NULL,
    medicine_id int4 NULL,
    quantity int4 NOT NULL,
    price numeric(10, 2) NOT NULL,
    CONSTRAINT sale_items_pkey PRIMARY KEY (sale_item_id),
    CONSTRAINT sale_items_medicine_id_fkey FOREIGN KEY (medicine_id) REFERENCES public.medicines(medicine_id),
    CONSTRAINT sale_items_sale_id_fkey FOREIGN KEY (sale_id) REFERENCES public.sales(sale_id)
);
```

Индексы создаются для ускорения запросов:

```sql
CREATE INDEX idx_sales_customer ON sales (customer_id);
CREATE INDEX idx_prescriptions_medicine ON prescriptions (medicine_id);
```

---

## 5.2. Создание представлений и функций

### Представления
Представления упрощают выполнение сложных запросов. Пример представления для отчета по остаткам:

```sql
CREATE VIEW simple_inventory AS
SELECT m.name, m.quantity_in_stock, s.name AS supplier
FROM medicines m
LEFT JOIN suppliers s ON m.supplier_id = s.supplier_id;
```

### Функции
Функции выполняют автоматические действия. Пример функции для обновления последовательностей:

```sql
CREATE OR REPLACE FUNCTION update_sequence_after_delete()
RETURNS TRIGGER AS $$
BEGIN
    EXECUTE format('SELECT setval(''%s_%s_seq'', (SELECT COALESCE(MAX(%I), 0) + 1 FROM %I))',
                   TG_TABLE_NAME, TG_ARGV[0], TG_ARGV[0], TG_TABLE_NAME);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

---

## 5.3. Разработка интерфейса

Интерфейс приложения разработан с использованием библиотеки `tkinter` для Python и организован в виде модульной структуры, обеспечивающей удобство использования и поддержки. Основные компоненты интерфейса описаны ниже.

### Общая структура интерфейса

Интерфейс приложения включает следующие основные элементы:

1. **Главное окно**:
   - Меню навигации (таблицы, отчеты, управление пользователями).
   - Статусная строка с информацией о текущем пользователе.
   - Контейнер для отображения данных таблиц.

2. **Формы для работы с данными**:
   - Добавление, редактирование и удаление записей.
   - Автоматическая валидация данных (например, проверка email, телефона, дат).

3. **Таблицы для отображения данных**:
   - Используется виджет `Treeview` для отображения данных в табличном виде.
   - Поддержка поиска и фильтрации.

4. **Диалоговые окна**:
   - Для создания новых записей (например, добавление продажи).
   - Для просмотра деталей (например, детали продажи).

5. **Экспорт данных**:
   - Возможность экспорта отчетов в CSV-файлы.

### Примеры реализации функций интерфейса

1. **Главное окно и меню**

 - Главное окно приложения (`PharmacyApp`) содержит меню навигации, которое адаптируется в зависимости от роли пользователя. Пример реализации:

```python
class PharmacyApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Аптечная база данных")
        self.root.geometry("1200x700")
        self._setup_ui()

    def _setup_ui(self):
        # Создание меню
        self.menu_bar = tk.Menu(self.root)
        self.file_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.file_menu.add_command(label="Выход", command=self.root.quit)
        self.menu_bar.add_cascade(label="Файл", menu=self.file_menu)

        self.tables_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.menu_bar.add_cascade(label="Таблицы", menu=self.tables_menu)

        self.user_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.user_menu.add_command(label="Войти", command=self.show_login)
        self.user_menu.add_command(label="Выйти", command=self.logout)
        self.menu_bar.add_cascade(label="Пользователь", menu=self.user_menu)

        self.reports_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.reports_menu.add_command(
            label="Простые остатки",
            command=self.show_simple_report
        )
        self.menu_bar.add_cascade(label="Отчёты", menu=self.reports_menu)

        self.root.config(menu=self.menu_bar)
```

2. **Отображение данных в таблицах**

 - Для отображения данных используется виджет `Treeview`. Пример метода для загрузки данных в таблицу:

```python
def show_table(self, table_name: str):
    for widget in self.main_frame.winfo_children():
        widget.destroy()
    try:
        data = self.db.get_table_data(table_name)
        columns = self.db.get_table_columns(table_name)
        if not data or not columns:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные таблицы {table_name}")
            return
    except Exception as e:
        messagebox.showerror("Ошибка", f"Не удалось загрузить данные: {e}")
        return

    tree = ttk.Treeview(self.main_frame, columns=columns, show='headings')
    for col in columns:
        tree.heading(col, text=col)
        tree.column(col, width=100, anchor=tk.W)

    for row in data:
        tree.insert('', tk.END, values=[row[col] for col in row])

    scrollbar = ttk.Scrollbar(self.main_frame, orient=tk.VERTICAL, command=tree.yview)
    tree.configure(yscroll=scrollbar.set)
    tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
```

3. **Формы для добавления и редактирования данных**

 - Для добавления и редактирования данных используется класс `EditDialog`, который создает диалоговые окна с автоматической валидацией полей. Пример метода для настройки формы:

```python
class EditDialog:
    def _setup_ui(self):
        main_frame = ttk.Frame(self.window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        columns = self.db.get_table_columns(self.table_name)
        db_columns = self.db._get_db_columns(self.table_name)

        record_data = {}
        if not self.is_new:
            record_data = self.db.get_record(self.table_name, self.record_id)

        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            )
        )
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        for i, (label, db_col) in enumerate(zip(columns, db_columns)):
            frame = ttk.Frame(scrollable_frame)
            frame.grid(row=i, column=0, sticky="ew", padx=5, pady=5)
            ttk.Label(frame, text=f"{label}:").pack(side="left")

            var = tk.StringVar()
            entry = ttk.Entry(frame, textvariable=var)
            entry.pack(side="left", fill="x", expand=True, padx=5)

            if db_col in record_data:
                var.set(str(record_data[db_col]) if record_data[db_col] is not None else "")
            self.fields[db_col] = ('entry', var, None)
```

4. **Экспорт данных в CSV**

 - Для экспорта данных используется метод `_export_to_csv`, который сохраняет данные в файл формата CSV. Пример реализации:

```python
def _export_to_csv(self, data, report_name):
    from csv import writer
    from datetime import datetime
    import os

    if not data:
        messagebox.showwarning("Ошибка", "Нет данных для экспорта")
        return

    filename = f"{report_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            csv_writer = writer(f)
            if isinstance(data[0], dict):
                csv_writer.writerow(data[0].keys())
            else:
                csv_writer.writerow([f"Column_{i}" for i in range(len(data[0]))])
            for row in data:
                if isinstance(row, dict):
                    csv_writer.writerow(row.values())
                else:
                    csv_writer.writerow(row)
        messagebox.showinfo("Успех", f"Отчёт сохранён как:\n{os.path.abspath(filename)}")
    except Exception as e:
        messagebox.showerror("Ошибка", f"Ошибка экспорта:\n{str(e)}")
```

### Особенности реализации

1. **Автоматическая валидация данных**:
   - Все поля проверяются на соответствие типам данных и ограничениям (например, email, телефон, дата).
   - Валидация выполняется с помощью класса `DataValidator`.

2. **Обработка внешних ключей**:
   - Для полей, представляющих внешние ключи, используются выпадающие списки (`Combobox`), заполненные актуальными данными из связанных таблиц.

3. **Обработка ошибок**:
   - Все операции с базой данных выполняются с обработкой исключений.
   - Пользователю выводятся информативные сообщения об ошибках.

## 5.4. Назначение прав доступа

Права доступа определяются на основе ролей:

1. **Администратор (ADMIN)**:
   - Полный доступ ко всем таблицам и функциям.
   - Управление пользователями системы.

2. **Фармацевт (PHARMACIST)**:
   - Доступ к таблицам `customers`, `medicines`, `prescriptions`, `sales`, `sale_items`.
   - Возможность создавать и просматривать продажи.

3. **Менеджер (MANAGER)**:
   - Доступ к таблицам `suppliers`, `medicines`, `purchases`, `purchase_items`.
   - Управление закупками и поставщиками.

4. **Гость (GUEST)**:
   - Только просмотр данных (например, информация о лекарствах).

Реализация прав доступа выполняется через проверку роли пользователя в приложении.

---

## 5.5. Разработка стратегии резервного копирования базы данных

Стратегия резервного копирования включает:

1. **Автоматическое резервное копирование**:
   - Используется утилита `pg_dump` для создания дампа базы данных.
   - Пример команды:
     ```bash
     pg_dump -U zhunya -d pharmacy -f backup.sql
     ```

2. **Планирование резервного копирования**:
   - Настройка cron-задач для регулярного выполнения резервного копирования.
   - Пример cron-задачи (ежедневное резервное копирование в 2 часа ночи):
     ```bash
     0 2 * * * pg_dump -U zhunya -d pharmacy -f /path/to/backup/$(date +\%Y\%m\%d)_pharmacy_backup.sql
     ```

3. **Хранение резервных копий**:
   - Резервные копии хранятся в безопасном месте (локально или в облачном хранилище).
   - Удаление старых копий через определенный период (например, 30 дней).

4. **Восстановление данных**:
   - Используется команда `psql` для восстановления базы данных из дампа:
     ```bash
     psql -U zhunya -d pharmacy -f backup.sql
     ```


# <a id=conclusion>Заключение</a>

В результате выполнения курсовой работы была успешно разработана и реализована информационная система управления аптекой, включающая следующие ключевые компоненты:

1. **Полноценную структуру базы данных**:
- 10 взаимосвязанных таблиц
- Систему ограничений целостности (PRIMARY KEY, FOREIGN KEY, CHECK)
- Индексацию для оптимизации запросов
- Систему последовательностей для генерации уникальных идентификаторов

2. **Функциональные возможности системы**:
- Управление запасами лекарственных средств
- Обработка продаж и закупок
- Работа с рецептами и клиентами
- Контроль сроков годности препаратов
- Формирование различных отчетов

3. **Аналитические инструменты**:
- Представления для упрощенного доступа к данным
- Функции для автоматизации рутинных операций
- Возможность формирования аналитических отчетов по:
  - Динамике продаж
  - Остаткам товаров
  - Потребности в закупках

**Преимущества внедрения системы**:
- Автоматизация рутинных процессов учета
- Снижение количества ошибок при работе с данными
- Повышение эффективности работы персонала
- Возможность оперативного получения аналитической информации
- Улучшение качества обслуживания клиентов

**Перспективы развития**:
- Внедрение мобильного интерфейса
- Интеграция с системами страховых компаний
- Добавление функционала электронных рецептов
- Реализация системы уведомлений о заканчивающихся препаратах
- Внедрение модуля прогнозирования спроса

Разработанная система представляет собой комплексное решение для автоматизации процессов управления аптекой и может быть рекомендована к внедрению в реальную практику с возможностью дальнейшего расширения функционала.

# <a id=literature>Список использованных информационных источников</a>

1. **Онлайн-ресурсы:**
   - PostgreSQL. (n.d.). *PostgreSQL Documentation*. Retrieved from [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)
   - Qt Company. Qt for Python Documentation. [Электронный ресурс]. URL: https://doc.qt.io/qtforpython-6/
   - PGdocs. *Введние в представления*. Retrieved from [https://pgdocs.ru/gruber/ch20.html](https://pgdocs.ru/gruber/ch20.html)
   - Хабр. *Индексы в PostgreSQL*. Retrieved from [https://habr.com/ru/companies/postgrespro/articles/326096/](https://habr.com/ru/companies/postgrespro/articles/326096/)
   - SQL-Ex blog. *Функции PostgreSQL: сила функций пользователя*. [https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html](https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html)
   - Docs.python.org. *tkinter — Python interface*. [Электронный ресурс]. URL: https://docs.python.org/3/library/tkinter.html 
2. **Справочные системы:**
   - DBeaver. *DBeaver Documentation*. Retrieved from [https://dbeaver.com/docs/dbeaver/](https://dbeaver.com/docs/dbeaver/)
   - Psycopg. *Psycopg – PostgreSQL database adapter for Python*. Retrieved from [https://www.psycopg.org/docs/](https://www.psycopg.org/docs/)

[Вернуться к содержанию](#content)
